/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2026 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void) {
	/* ------------------------------------------------------------------------------------------------
	 * Note: From the documentation associated with the board (User Manual, MCU reference and schematics) one derives the information
	 LED BLUE PB7 137
	 LED RED PB14 75

	 P stands for Port.
	 B is the specific bank of pins (Microcontrollers group pins into Port A, Port B, Port C, etc.).
	 7 or 14 is the specific pin number within that bank.

	 The Mapping Number: 137 and 75

	 In many C frameworks (like Arduino or specific RTOS environments), the software doesn't refer to pins as "PB7."
	 Instead, it assigns every pin a unique integer index.

	 When you call a function like digitalWrite(137, HIGH);,
	 the underlying library looks at its internal table, sees that 137 corresponds to Port B, Pin 7, and sends the electrical signal
	 there.
	 ---------------------------------------------------------------------------------------------    */

	//Step 1: enable the clock register for the  AHB1ENR where  GPIOB  is connected
	uint32_t volatile *pRCC_AHB1ENR = (uint32_t*) (0x40023800 + 0x30);
	*pRCC_AHB1ENR |= (1 << 1); //see RM0090 RCC AHB1 peripheral clock register (RCC_AHB1ENR)

	//Step 2: Set the mode of the GPIO to output user led2 LED BLUE PB7 137
	uint32_t volatile *pGPIOB_MODER = (uint32_t*) (0x40020400);

	//clear the bits where the mode is to be set
	*pGPIOB_MODER &= (~(3 << 14)); // reset the two bits all at once , note that 3 = 11 binary

	//set the state for MODER7[1:0] to '01' that corresponds to General Purpose Output Mode
	*pGPIOB_MODER |= (1 << 14);

	//Step 3: set the GPIO port output data register
	uint32_t volatile *pGPIOB_ODR = (uint32_t*) (0x40020400 + 0x14);

	for (;;) {
		*pGPIOB_ODR |= (1 << 7);

		for (volatile uint32_t i =0; i < 900000; i++)
			;

		*pGPIOB_ODR &= ~(1 << 7);

		for (volatile uint32_t i = 0; i < 900000; i++)
			;

	}
}
